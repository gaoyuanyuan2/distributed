# Redis
### Redis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库 ，epoll 所以高性能

## 用途、应用场景
<br>1.	数据缓存（商品数据、新闻、热点数据）（pojo可以缓存，计算性缓存命中率很低没必要缓存）
<br><br>2.	单点登录
<br><br>3.	秒杀、抢购
<br><br>4.	网站访问排名…
<br><br>5.	应用的模块开发
<br><br>6.  Redis正是我想要找的那种数据库一它内置了集合数据类型，并支持对集合执行交集、并集、差集等集合计算操作，其中的交集计算操作可以直接用于实现我想要的共同关注功能。
## 持久化
<br>1. 	RDB持久化
<br>RDB压缩的二进制文件用于保存和还原Redis服务器所有数据库中的所有键值对数据）。SAVE命令由服务器进程直接保存操作，所有该命令会阻塞服务器。BGSAVE
由子进程执行保存操作，所以该命令不会阻塞服务器。（间隔保存，会丢失数据）
<br><br>2. 	AOF持久化
<br>AOF日志文件通过保存所有修改数据库的命令请求来记录服务器的数据库状态。AOF重写文件体积变小。（每秒同步，每修改同步，不同步）文件大、效率较低。新文件会覆盖旧的文件（定时转移走）。 
### redis持久化机制
<br>redis提供了两种持久化策略
### RDB
<br>RDB的持久化策略： 按照规则定时将内存的数据同步到磁盘
<br>snapshot
<br>redis在指定的情况下会触发快照
<br><br>1.	自己配置的快照规则
<br>save <seconds><changes>
<br>save 900 1  当在900秒内被更改的key的数量大于1的时候，就执行快照
<br>save 300 10
<br>save 60 10000
<br><br>2.	save或者bgsave
<br>save: 执行内存的数据同步到磁盘的操作，这个操作会阻塞客户端的请求
<br>bgsave: 在后台异步执行快照操作，这个操作不会阻塞客户端的请求
<br><br>3.	执行flushall的时候
<br>清除内存的所有数据，只要快照的规则不为空，也就是第一个规则存在。那么redis会执行快照
<br><br>4.	执行复制的时候
### 快照的实现原理
<br>1：redis使用fork函数复制一份当前进程的副本(子进程)
<br><br>2：父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件
<br><br>3：当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此，一次快照操作完成。  
<br><br>注意：redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。 这就使得我们可以通过定时备份RDB文件来实现redis数据库的备份， RDB文件是经过压缩的二进制文件，占用的空间会小于内存中的数据，更加利于传输。
#### RDB的优缺点
<br>1.	使用RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这个时候我们就需要根据具体的应用场景，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受范围。如果数据相对来说比较重要，希望将损失降到最小，则可以使用AOF方式进行持久化
<br><br>2.	RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无序执行任何磁盘I/O操作。同时这个也是一个缺点，如果数据集比较大的时候，fork可以能比较耗时，造成服务器在一段时间内停止处理客户端的请求；
### 实践
<br>修改redis.conf中的appendonly yes ; 重启后执行对数据的变更命令， 会在bin目录下生成对应的.aof文件， aof文件中会记录所有的操作命令
<br>如下两个参数可以去对aof文件做优化
<br>auto-aof-rewrite-percentage 100表示当前aof文件大小超过上一次aof文件大小的百分之多少的时候会进行重写。如果之前没有重写过，以启动时aof文件大小为准
<br>auto-aof-rewrite-min-size 64mb限制允许重写最小aof文件大小，也就是文件大小小于64mb的时候，不需要进行优化
### AOF
<br>AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这一过程显然会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能
### 实践
<br>默认情况下Redis没有开启AOF（appendonlyfile）方式的持久化，可以通过appendonly参数启用，在redis.conf中找到 appendonly yes
<br>开启AOF持久化后每执行一条会更改Redis中的数据的命令后，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是apendonly.aof. 可以在redis.conf中的属性 appendfilename appendonlyh.aof修改
### aof重写的原理
<br>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松
###  同步磁盘数据
<br>redis每次更改数据的时候， aof机制都会讲命令记录到aof文件，但是实际上由于操作系统的缓存机制，数据并没有实时写入到硬盘，而是进入硬盘缓存。再通过硬盘缓存机制去刷新到保存到文件
<br>appendfsync always每次执行写入都会进行同步 ， 这个是最安全但是是效率比较低的方式
<br>appendfsync everysec每一秒执行
<br>appendfsync no不主动进行同步操作，由操作系统去执行，这个是最快但是最不安全的方式
### aof文件损坏以后如何修复
<br>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。
<br>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：
<br><br>1.	为现有的 AOF 文件创建一个备份。
<br><br>2.	使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。
<br><br>redis-check-aof --fix
<br>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。
### RDB 和 AOF ,如何选择
<br>一般来说,如果对数据的安全性要求非常高的话，应该同时使用两种持久化功能。如果可以承受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快 。
<br>两种持久化策略可以同时使用，也可以使用其中一种。如果同时使用的话， 那么Redis重启时，会优先使用AOF文件来还原数据
<br><br>密码设置
<br>requirepass foobaredbind

## 原理
<br>1.	链表:实现Redis的各种功能,比如列表键、发布与订阅、满查询、监视器。
<br><br>2.	字典：使用哈希表作为底层实现。字典被用作数据库（哈希键）的底层实现。
<br><br>3.	解决键冲突： Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这样就解决了键冲突问题。
<br><br>4.	跳跃表是有序集合的底层实现之一。
<br><br>5.	整数集合是集合键的底层实现之一。（底层实现为数组）
<br><br>6.	压缩列表是列表键和哈希键的底层实现之一。
<br><br>7.	Redis的对象系统实现了基于引用计数的内存回收机制。
<br><br>8. 	Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象。当一个对象不再被使用时，该对象所占用的内存就会自动释放。
<br><br>9.	设置键的生存时间或过期时间。
<br><br>10.	当主服务器删除一个过期键之后，他会向所有从服务器发送一条DEL命令，显式地删除过期键。当Redis命令对数据库进行修改之后，服务器会根据配置项客户端发送数据库通知。
<br><br>11.	Redis服务器是一个事件驱动程序，服务器处理的事件分时间事件和文件事件两类。
<br><br>12.	客户端：Redis服务器是典型的一对多服务器程序：通过使用I/O多路复用技术实现文件事件处理器。

## 发布和订阅
<br>由PUBLISH,SUBSCRIBE,PSUBSCRIBE命令组成。
<br>发送到频道，订阅频道（PUBLISH <channel><message>）。
<br><br>Redis实现消息队列原理
<br>发布者和订阅者模式：发布者发送消息到队列，每个订阅者都能收到一样的消息。 
<br>生产者和消费者模式：生产者将消息放入队列，多个消费者共同监听，谁先抢到资源，谁就从队列中取走消息去处理。注意，每个消息只能最多被一个消费者接收。

## Redis事务
<br>MULTI(队列中、原子化地执行)（发起）
<br>EXEC（当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，如果事务执行中止，那么EXEC命令就会返回一个Null值）（提交）
<br>DISCARD清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。（回滚）
<br>WATCH等命令来实现事物功能。
<br>运行时错误 事务不回滚
<br><br>MULTI去开启事务
<br>EXEC去执行事务

## redis的安装
<br>1.	下载redis安装包 
<br><br>2.	tar -zxvf 安装包
<br><br>3.	在redis目录下 执行 make
<br><br>4.	可以通过make test测试编译状态
<br><br>5.	make install [prefix=/path]完成安装

## 命令
<br>1.  启动停止redis
<br>./redis-server ../redis.conf
<br>./redis-cli shutdown
<br>以后台进程的方式启动，修改redis.conf   daemonize =yes
<br><br>2.  连接到redis的命令
<br>./redis-cli -h 127.0.0.1 -p 6379
<br><br>3.  其他命令说明
<br>Redis-server 启动服务
<br>Redis-cli 访问到redis的控制台
<br>redis-benchmark 性能测试的工具
<br>redis-check-aof aof文件进行检测的工具
<br>redis-check-dump  rdb文件检查工具
<br>redis-sentinel sentinel 服务器配置

## 多数据支持
<br>默认支持16个数据库；可以理解为一个命名空间；跟关系型数据库不一样的点
<br><br>1.	redis不支持自定义数据库名词
<br><br>2.	每个数据库不能单独设置授权
<br><br>3.	每个数据库之间并不是完全隔离的。 可以通过flushall命令清空redis实例面的所有数据库中的数据
<br><br>通过 select dbid去选择不同的数据库命名空间 。 dbid的取值范围默认是0-15

## 使用入门
<br>1.	获得一个符合匹配规则的键名列表
<br>keys pattern  [? / * /[]]
<br>keys mic:hobby
<br><br>2.	判断一个键是否存在 ， EXISTS key 
<br><br>3.	type key 去获得这个key的数据结构类型

## 各种数据结构的使用
###  字符类型
###  散列类型
###  列表类型
###  集合类型
###  有序集合
<br>1.  字符类型
<br>一个字符类型的key默认存储的最大容量是512M
<br>赋值和取值
<br>SETkey  value
<br>GETkey
<br>递增数字
<br>incr key
<br><br>错误的演示
<br>int value= get key;
<br>value =value +1;
<br>set key value;
<br><br>key的设计
<br>对象类型:对象id:对象属性:对象子属性
<br>建议对key进行分类，同步在wiki统一管理
<br>短信重发机制
<br><br>incryby key increment  递增指定的整数
<br>decr key   原子递减
<br>append key value 向指定的key追加字符串
<br>strlenkey  获得key对应的value的长度
<br>mgetkey key..同时获得多个key的value
<br>mset key value  key value  key value …
<br>setnx
<br><br>2.  列表类型
<br>list, 可以存储一个有序的字符串列表
<br>LPUSH/RPUSH： 从左边或者右边push数据
<br>LPUSH/RPUSH key value value …
<br>｛17 20 19 18 16｝
<br><br>llen num  获得列表的长度
<br>lrangekey  start stop   ;  索引可以是负数， -1表示最右边的第一个元素
<br>lrem key count value
<br>lset key index value
<br>LPOP/RPOP : 取数据
<br>应用场景：可以用来做分布式消息队列
<br><br>3.  散列类型
<br>hash key value不支持数据类型的嵌套
<br>比较适合存储对象
<br>person
<br>age  18
<br>sex   男
<br>name mic
<br><br>hset key field value
<br>hget key filed 
<br><br>hmset key filed value [filed value …]一次性设置多个值
<br>hmget key field field …一次性获得多个值
<br>hgetall key获得hash的所有信息，包括key和value
<br>hexists key field 判断字段是否存在。 存在返回1.不存在返回0
<br>hincryby
<br>hsetnx
<br>hdel key field [field …]删除一个或者多个字段
<br><br>4.  集合类型
<br>set跟list不一样的点。集合类型不能存在重复的数据。而且是无序的
<br>saddkey member [member ...]增加数据； 如果value已经存在，则会忽略存在的值，并且返回成功加入的元素的数量
<br>srem key member  删除元素
<br>smemberskey获得所有数据
<br><br>sdiffkey key …对多个集合执行差集运算
<br>sunion对多个集合执行并集操作,同时存在在两个集合里的所有值
<br><br>5.  有序集合
<br>zadd key score member
<br><br>zrange key start stop [withscores] 去获得元素。 withscores是可以获得元素的分数
<br>如果两个元素的score是相同的话，那么根据(0<9<A<Z<a<z) 方式从小到大
<br>网站访问的前10名。

## 分布式锁的实现
### 锁是用来解决什么问题的;
<br>1.	一个进程中的多个线程，多个线程并发访问同一个资源的时候，如何解决线程安全问题。
<br><br>2.	一个分布式架构系统中的两个模块同时去访问一个文件对文件进行读写操作
<br><br>3.	多个应用对同一条数据做修改的时候，如何保证数据的安全性
<br><br>在但进程中，我们可以用到synchronized、lock之类的同步操作去解决，但是对于分布式架构下多进程的情况下，如何做到跨进程的锁。就需要借助一些第三方手段来完成
<br><br>设计一个分布式所需要解决的问题
<br><br>分布式锁的解决方案
<br>1.	怎么去获取锁
### 数据库，通过唯一约束
```sql
lock(
     id  int(11),
     methodName  varchar(100),
     memo varchar(1000) ,
     modifyTime timestamp,
    unique key mn(method) -- 唯一约束
)
```
<br><br>获取锁的伪代码

```java

try{
    exec  insert into lock(methodName,memo) values(‘method’,’desc’);
    return true;
}Catch(DuplicateException e){
return false;
}

```

<br><br>释放锁

```sql
delete from lock where methodName=’’;
```

#### 存在的需要思考的问题
<br>1.	锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁
<br><br>2.	锁是非阻塞的，数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作
<br><br>3.	锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁
### zookeeper实现分布式锁
<br>利用zookeeper的唯一节点特性或者有序临时节点特性获得最小节点作为锁. zookeeper 的实现相对简单，通过curator客户端，已经对锁的操作进行了封装
<br><br>同时写一个结点，写同一个结点watch

### zookeeper的优势
<br>1.	可靠性高、实现简单
<br><br>2.	zookeeper因为临时节点的特性，如果因为其他客户端因为异常和zookeeper连接中断了，那么节点会被删除，意味着锁会被自动释放
<br><br>3.	zookeeper本身提供了一套很好的集群方案，比较稳定
<br><br>4.	释放锁操作，会有watch通知机制，也就是服务器端会主动发送消息给客户端这个锁已经被释放了
### 基于缓存的分布式锁实现
<br>redis中有一个setNx命令，这个命令只有在key不存在的情况下为key设置值。所以可以利用这个特性来实现分布式锁的操作

## redis多路复用机制
<br>linux的内核会把所有外部设备都看作一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个 file descriptor（文件描述符）。对于一个socket的读写也会有响应的描述符，称为socketfd(socket描述符)。而IO多路复用是指内核一旦发现进程指定的一个或者多个文件描述符IO条件准备好以后就通知该进程
<br>IO多路复用又称为事件驱动，操作系统提供了一个功能，当某个socket可读或者可写的时候，它会给一个通知。当配合非阻塞socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据。操作系统的功能通过select/pool/epoll/kqueue之类的系统调用函数来使用，这些函数可以同时监视多个描述符的读写就绪情况，这样多个描述符的I/O操作都能在一个线程内并发交替完成，这就叫I/O多路复用，这里的复用指的是同一个线程
<br>多路复用的优势在于用户可以在一个线程内同时处理多个socket的 io请求。达到同一个线程同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到目的

## redis中使用lua脚本
### lua脚本
<br>Lua是一个高效的轻量级脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能
### 使用脚本的好处
<br>1.	减少网络开销，在Lua脚本中可以把多个命令放在同一个脚本中运行
<br><br>2.	原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说，编写脚本的过程中无需担心会出现竞态条件
<br><br>3.	复用性，客户端发送的脚本会永远存储在redis中，这意味着其他客户端可以复用这一脚本来完成同样的逻辑

## 集群
<br>复制（master、slave）

<br><br>节点通过握手来将其他节点添加到自己所处的集群当中。无中心节点
<br>集群中的16384个槽可以分别平均指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其他节点，
<br>集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。
<br>集群中的节点通过发送和接收消息来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FAIL。
 
### 配置过程
<br>修改11.140和11.141的redis.conf文件，增加slaveof masterip masterport
<br>slaveof192.168.11.138 6379
### 实现原理
<br><br>1.	slave第一次或者重连到master上以后，会向master发送一个SYNC的命令
<br><br>2.	master收到SYNC的时候，会做两件事
<br><br>a)	执行bgsave（rdb的快照文件）
<br><br>b)	master会把新收到的修改命令存入到缓冲区
### 缺点
<br>没有办法对master进行动态选举
<br>复制的方式
<br><br>1.	基于rdb文件的复制（第一次连接或者重连的时候）
<br><br>2.	无硬盘复制
<br><br>3.	增量复制
<br><br>PSYNC master run id. offset
### 哨兵机制
<br>是Redis高可用性的解决方案。一般10s每次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者Sentinel
正在对主服务器进行故障转移操作是，发送频率会改成每秒一次。每个主节点一个从节点，故障从提主。自动。基数防脑裂。
<br><br>sentinel
<br><br>1.	监控master和salve是否正常运行
<br><br>2.	如果master出现故障，那么会把其中一台salve数据升级为master
<br><br>集群（redis3.0以后的功能）
<br>根据key的hash值取模 服务器的数量 。 
<br>hash
### 集群的原理
<br>官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。
这时，如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为主节点，
整个集群继续对外提供服务。这非常类似服务器节点通过Sentinel监控架构成主从结构，只是Redis Cluster本身提供了故障转移容错的能力。
<br><br>slot（槽）的概念，在redis集群中一共会有16384个槽，
<br>根据key的CRC16算法，得到的结果再对16384进行取模。 假如有3个节点
<br>node1  0 5460
<br>node2  5461 10922
<br>node3  10923 16383
<br>节点新增
<br>node4  0-1364,5461-6826,10923-12287
<br>删除节点
<br>先将节点的数据移动到其他节点上，然后才能执行删除
### 市面上提供了集群方案
<br>1.	redis shardding   而且jedis客户端就支持shardding操作SharddingJedis； 增加和减少节点的问题； pre shardding
<br>3台虚拟机 redis。但是我部署了9个节点 。每一台部署3个redis增加cpu的利用率
<br>9台虚拟机单独拆分到9台服务器
<br><br>2.	codis基于redis2.8.13分支开发了一个codis-server
<br><br>3.	twemproxy  twitter提供的开源解决方案

## 缓存更新
<br>redis缓存的更新（2pc 3pc 强一致，但是效率低）
<br><br>1.  先删除缓存，再更新数据库(并发操作更新还没有完成，就查询，load之前错误数据到缓存，之后数据都会出现脏读)
<br><br>2.  先更新数据库，更新成功后，让缓存失效（也会出现脏读，概率低一些）
<br><br>3.  更新数据的时候，只更新缓存，不更新数据库，然后同步异步调度去批量更新数据库（性能高，数据不是强一致）

## 穿透、击穿
<br>1.  缓存穿透 布隆过滤器
<br><br>2.  缓存击穿 同时失效（随机时间） 互斥锁让请求排队等待

## C字符串，SDS
<br>比起C字符串，SDS具有以下优点:
<br><br>1)常数复杂度获取字符串长度。
<br><br>2)杜绝缓冲区溢出。
<br><br>3)减少修改字符串长度时所需的内存重分配次数。
<br><br>4)二进制安全。
<br><br>5)兼容部分C字符串函数。

<br><br>
|C字符串和SDS之间的区别|
|C字符串|SDS|
|:--:|:--:|
|获取字符串长度的复杂度为O(M) |  获取字符串长度的复杂度为0(1) (SDS在len属性中记录了SDS本身的长度)|
|API是不安全的，可能会造成缓冲区溢出 |  API是安全的,不会造成缓冲区溢出|
|修改字符串长度N次必然需要执行N次内存重分配只能保存文本数据 |修改字符串长度N次最多需要执行N次内存重分配可以保存文本或者二进制数据|
|可以使用所有<string .h>库中的函数   | 可以使用一部分<string.h>库中的函数|

<br><br>与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性:当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，
如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。

<br><br>C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，
程序都总要对保存这个C字符串的数组进行一次内存重分配操作
    
<br><br>为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联:在SDS中,  
buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。
通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。
<br>1. 空间预分配
<br>空间预分配用于优化SDS的字符串增长操作:  当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。
<br>eg. 如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节(额外的一字节用于保存空字符)。
<br>如果对SDS进行修改之后，SDS的长度将大于等于1MB,那么程序会分配1MB的未
使用空间。
<br>eg. 如果进行修改之后，SDS的len将变成30MB,那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB + 1MB + 1byte。
<br>2.  惰性空间释放
<br>执行sdstrim之后的SDS并没有释放多出来的8字节空间，而是将这8字节空间作为未使用空间保留在了SDS里面，如果将来要对SDS进行增长操作的话，这些未使用空间就可能会派上用场

## 链表
<br>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。
<br><br>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。
<br><br>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。
<br><br>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针,以及链表长度等信息。
<br><br>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL,所以Redis的链表实现是无环链表。
<br><br>通过为链表设置不同的类型特定函数, Redis 的链表可以用于保存各种不同类型的值。

Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一一个键值对。
接下来的三个小节将分别介绍Redis的哈希表、哈希表节点以及字典的实现。

## 字典
<br>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。
<br><br>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。
<br><br>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。
<br><br>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL,所以Redis的链表实现是无环链表。
<br><br>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。
<br><br>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

<br><br>哈希算法
当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

<br><br>Redis的哈希表使用链地址法( separate chaining)来解央键冲突，每个哈希表节点都有一一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。

<br><br>键k1和k2产生冲突，而解决冲突的办法就是使用next指针将键k2和k1所在的节点连接起来

<br><br>rehash
<br>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子(load factor)维持在-个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。

<br><br>哈希表的扩展与收缩
<br>当以下条件中的任意-一个被满足时，程序会自动开始对哈希表执行扩展操作:
<br><br>1)服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。
<br><br>2)服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。

## 跳跃表
<br><br> 跳跃表( skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。
<br><br> 跳跃表支持平均0(logN)、最坏0(M)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。
<br><br> 在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。
<br><br> Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多,又或者有序集合中元素的成员( member )是比较长的字符串时，Redis 就会使用跳跃表来作为有序集合键的底层实现。

## 整数集合
<br>整数集合( intset)是集合键的底层实现之一，当一个集合只包含整数值元素,并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。
<br>eg. 如果我们创建一一个 只包含五个元素的集合键，并且集合中的所有元素都是整数值，那么这个集合键的底层实现就会是整数集合

<br><br>整数集合是集合键的底层实现之一。
<br>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型,  改变这个数组的类型。
<br>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。整数集合只支持升级操作，不支持降级操作。

## 压缩列表
<br>压缩列表( ziplist )是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。
<br><br>压缩列表是一种为节约内存而开发的顺序型数据结构。压缩列表被用作列表键和哈希键的底层实现之一。
<br>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
<br>添加新节点到压缩列表,  或者从压缩列表中删除节点，可能会引发连锁更新操作,但这种操作出现的几率并不高。


## 对象
<br>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少-种我们前面所介绍的数据结构。
<br>通过这五种不同类型的对象，Redis 可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。
<br>除此之外，  Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放;另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。
<br>最后，  Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。

<br><br>而另一种命令只能对特定类型的键执行，比如说:
<br>1.  SET、GET、APPEND、STRLEN等命令只能对字符串键执行;口HDEL、HSET、HGET、HLEN等命令只能对哈希键执行;
<br>2.  RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行;口SADD、SPOP、SINTER、SCARD等命令只能对集合键执行;
<br>3.  ZADD、ZCARD、ZRANK、 ZSCORE等命令只能对有序集合键执行;

<br><br>对象的引用计数信息会随着对象的使用状态而不断变化:
<br>1.  在创建一个新对象时，引用计数的值会被初始化为1;
<br>2.  当对象被一个新程序使用时，它的引用计数值会被增一;
<br>3.  当对象不再被一个程序使用时，它的引用计数值会被减一;
<br>4.  当对象的引用计数值变为0时，对象所占用的内存会被释放。

<br><br> 重点
<br>1.  Redis数据库中的每个键值对的键和值都是一个对象。
<br>2.  Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。
服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。
<br>3.  Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。
<br>4.  Redis 会共享值为0到9999的字符串对象。
<br>5.  对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

## 数据库
<br>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。
<br><br>通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能一这 就是SELECT命令的实现原理。
<br><br>在数次切换数据库之后，你很可能会忘记自己当前正在使用的是哪个数据库。当出现这种情况时，为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后才执行别的命令。
<br><br>键空间和用户所见的数据库是直接对应的:
<br>1.  键空间的键也就是数据库的键，每个键都是一个字符串对象。
<br>2.  键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、
集合对象和有序集合对象中的任意一种Redis对象。
<br><br>数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的
<br><br>读写键空间时的维护操作
<br>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作,还会执行一些额外的维护操作，其中包括:
<br><br>1.  在读取一个键之后(读操作和写操作都要对键进行读取),服务器会根据键是否存在来更新服务器的键空间命中( hit)次数或键空间不命中( miss)次数， 这两个值可以在INFO stats命令的keyspace_ hits 
属性和keyspace_misses属性中查看。
在读取一个键之后，服务器会更新键的LRU (最后一次使用)时间，这个值可以用于计算键的闲置时间,使用OBJECT idletime <key>命令可以查看键key的闲置时间。
如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。
<br><br>2.  如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏(dirty),从而让事务程序注意到这个键已经被修改过。
<br><br>3.  服务器每次修改一个键之后，都会对脏( dity )键计数器的值增1,这个计数器会触发服务器的持久化以及复制操作。
<br><br>4.  如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知，本章稍后讨论数据库通知功能的实现时会详细说明这一点。
<br><br>SETEX命令可以在设置一个字符串键的同时为键设置过期时间，因为这个命令是一个类型限定的命令(只能用于字符串键),所以本章不会对这个命令进行介绍，但SETEX命令设置过期时间的原理和本章介绍的EXPIRE命令设置过期时间的原理是完全一样的。
与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令,以秒或者毫秒精度给数据库中的某个键设置过期时间( expire time )。
<br><br>设置过期时间
<br>Redis有四个不同的命令可以用于设置键的生存时间(键可以存在多久)或过期时间(键什么时候会被删除):
<br><br>1.  EXPIRE <key> <tl>命令用于将键key的生存时间设置为ttl秒。
<br><br>2.  PEXPIRE <key> <ttl>命令用于将键key的生存时间设置为ttl毫秒。
<br><br>3.  EXPIREAT <key> <timestamp> 命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。
<br><br>4.  PEXPIREAT <key> <timestamp> 命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。
<br><br>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、 
EXPIREAT三个命令都是使用PEXPIREAT命令来实现的:无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。
<br><br>PERSIST命令就是PEXPIREAT命令的反操作: PERSIST命令在过期字典中查找给定的键、并解除键和值(过期时间)在过期字典中的关联。
<br><br>计算并返回剩余生存时间
<br>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余牛存时间。
<br><br>过期键的判定
<br>通过过期字典，程序可以用以下步骤检查-个给定键是否过期:
<br>1)检查给定键是否存在于过期字典:  如果存在，那么取得键的过期时间。
<br>2)检查当前UNIX时间截是否大于键的过期时间:如果是的话，那么键已经过期;否则的话，键未过期。
<br><br>实现过期键判定的另一种方法是使用TTL命令或者PTTL命令，  比如说，如果对某个键执行TTL命令，并且命令返回的值大于等于0，那么说明该键未过期。在实际中，Redis 检查键是否过期的方法和is_ expired 函数所描述的方法一致，因为直接访问字典比执行一个命令稍微快一些。

<br><br>实现过期键判定的另一种方法是使用TTL命令或者PTTL命令，  比如说，如果对某个键执行TTL命令，并且命令返回的值大于等于0，那么说明该键未过期。在实际中，Redis 检查键是否过期的方法和is_ expired 函数所描述的方法一致，因为直接访问字典比执行一个命令稍微快一些。     

<br><br>键空间和用户所见的数据库是直接对应的: 
<br>键空间的键也就是数据库的键，每个键都是一个字符串对象。
<br>键空间的值也就是数据库的值，  每个值可以是字符串对象、列表对象、哈希表对象、
<br>集合对象和有序集合对象中的任意一种Redis对象。

<br><br>过期键删除策略
<br>经过上一节的介绍，我们知道了数据库键的过期时间都保存在过期字典中，又知道了如何根据过期时间去判断一个键是否过期，现在剩下的问题是:如果一个键过期了,那么它什么时候会被删除呢?
<br>这个问题有三种可能的答案，它们分别代表了三种不同的删除策略: 
<br>1.  定时删除:在设置键的过期时间的同时，创建一个定时器( timer ),让定时器在键的过期时间来临时，立即执行对键的删除操作。
<br>2.  惰性删除:放任键过期不管,但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
<br>3.  定期删除:每隔一段时间，程序就对数据库进行-次检查,删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。
<br>在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。

<br><br>定时删除策略对内存是最友好的:通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。
<br>另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的:在过期键比较多的

<br><br>惰性删除策略对CPU时间来说是最友好的:程序只会在取出键时才对键进行过期检查,这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。
<br>惰性删除策略的缺点是，它对内存是最不友好的:如果-一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。

<br><br>定期删除
<br>从上面对定时删除和惰性删除的讨论来看,这两种删除方式在单-使用时都有明显的缺陷: 口定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。0惰性删除浪费太多内存，有内存泄漏的危险。定期删除策略是前两种策略的一种整合和折中:
<br>1.  定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
<br>2.  除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。
 <br><br>定期删除策略的难点是确定删除操作执行的时长和频率:
<br>1.  如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。
<br>2.  如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。
因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。 
 

<br><br>AOF、 RDB和复制功能对过期键的处理
<br>生成RDB文件在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。
<br>eg，如果数据库中包含三个键k1、k2、k3，并且k2已经过期，那么当执行SAVE命令或者BGSAVE命令时，程序只会将k1和k3的数据保存到RDB文件中，而k2则会被忽略。
<br>因此，数据库中包含过期键不会对生成新的RDB文件造成影响。
<br>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载人:
<br>如果服务器以主服务器模式运行，那么在载人RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载人到数据库中，而过期键则会被忽略，所以过期键对载人RDB文件的主服务器不会造成影响。
<br>如果服务器以从服务器模式运行，那么在载人RDB文件时，文件中保存的所有键，不论是否过期，都会被载人到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载人RDB文件的从服务器也不会造成影响。
<br>eg.  如果数据库中包含三个键k1、k2、k3,并且k2已经过期，那么当服务器启动时:
<br>如果服务器以主服务器模式运行，那么程序只会将k1和k3载人到数据库，k2会被忽略。
<br>如果服务器以从服务器模式运行，那么k1、k2和k3都会被载人到数据库。
 
<br> AOF文件写入当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。
<br>当过期键 鼓惰性删除或者定期删除之后，程序会向AOF文件追加( append)一条DEL命令，来显式地记录该键已被删除。
<br>eg.  如果客户端使用GET message 命令，试图访问过期的message键，那么服务器将执行以下三个动作:
<br>1.  从数据库中删除message键。
<br>2.  追加一条DEL message 命令到AOF文件。
<br>3.  向执行GET命令的客户端返回空回复。

<br><br>AOF重写
<br>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。
<br>eg.  如果数据库中包含三个键k1、k2、k3,并且k2已经过期，那么在进行重写工作时，程序只会对k1和k3进行重写，而k2则会被忽略。
<br>因此，数据库中包含过期键不会对AOF重写造成影响。

<br><br>复制
<br>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制:
<br>1.  主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。
<br>2.  从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键-样来处理过期键。
<br>3.  从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。

<br><br>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。
<br>eg.  有一对主从服务器，它们的数据库中都保存着同样的三个键message. xxx和YYY,  其中message为过期键。
<br>如果这时有客，户端向从服务器发送命令GET  message,那么从服务器将发现rmessage键已经过期，但从服务器并不会删除message键，  而是继续将message键的值返回给客户端，就好像message键并没有过期一样
<br>假设在此之后，有客户端向主服务器发送命令GET message,那么主服务器将发现键message已经过期:主服务器会删除message键，  向客户端返回空回复，并向从服务器发送DEL  message命令
<br>从服务器在接收到主服务器发来的DEL  message命令之后，也会从数据库中删除message键，在这之后，主从服务器都不再保存过期键message了

<br><br>重点
<br>1.  Redis 服务器的所有数据车都保存在redisServer.db数组中，而数据库的数量则由redisServer.db num属性保存。
<br>2.  客户端通过修改目标数据库指针，让它指向redisserver . db数组中的不同元素来切换不同的数据库。
<br>3.  数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对,而expires字典则负责保存键的过期时间。
<br>4.  因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。
<br>5.  数据库的键总是一个字符串对象，而值则可以是任意-种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。
<br>6.  expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。
<br>7.  Redis 使用惰性删除和定期删除两种策略来删除过期的键:惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔-段时间主动查找并删除过期键。
<br>8.  执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。0执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。
<br>9.  当一个过期键被删除之后， 服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。
<br>10.  当主服务器刪除-一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。
<br>11.  从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令,这种统一中心化的过期键删除策略可以保证主从服务器数据的一致性。
<br>12.  当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。


























































