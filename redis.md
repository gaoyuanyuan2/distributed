# Redis
### Redis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库 ，epoll 所以高性能

## 用途、应用场景
<br>1.	数据缓存（商品数据、新闻、热点数据）（pojo可以缓存，计算性缓存命中率很低没必要缓存）
<br><br>2.	单点登录
<br><br>3.	秒杀、抢购
<br><br>4.	网站访问排名…
<br><br>5.	应用的模块开发
<br><br>6.  Redis正是我想要找的那种数据库一它内置了集合数据类型，并支持对集合执行交集、并集、差集等集合计算操作，其中的交集计算操作可以直接用于实现我想要的共同关注功能。
## 持久化
<br>1. 	RDB持久化
<br>RDB压缩的二进制文件用于保存和还原Redis服务器所有数据库中的所有键值对数据）。SAVE命令由服务器进程直接保存操作，所有该命令会阻塞服务器。`BGSAVE`
由子进程执行保存操作，所以该命令不会阻塞服务器。（间隔保存，会丢失数据）
<br><br>2. 	AOF持久化
<br>AOF日志文件通过保存所有修改数据库的命令请求来记录服务器的数据库状态。AOF重写文件体积变小。（每秒同步，每修改同步，不同步）文件大、效率较低。新文件会覆盖旧的文件（定时转移走）。 
### redis持久化机制
<br>redis提供了两种持久化策略
### RDB
<br>RDB的持久化策略： 按照规则定时将内存的数据同步到磁盘
<br>snapshot
<br>redis在指定的情况下会触发快照
<br><br>1.	自己配置的快照规则
<br>save <seconds><changes>
<br>save 900 1  当在900秒内被更改的key的数量大于1的时候，就执行快照
<br>save 300 10
<br>save 60 10000
<br><br>2.	save或者`bgsave`
<br>save: 执行内存的数据同步到磁盘的操作，这个操作会阻塞客户端的请求
<br>`bgsave`: 在后台异步执行快照操作，这个操作不会阻塞客户端的请求
<br><br>3.	执行`flushall`的时候
<br>清除内存的所有数据，只要快照的规则不为空，也就是第一个规则存在。那么redis会执行快照
<br><br>4.	执行复制的时候
### 快照的实现原理
<br>1：redis使用fork函数复制一份当前进程的副本(子进程)
<br><br>2：父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件
<br><br>3：当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此，一次快照操作完成。  
<br><br>注意：redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。  这就使得我们可以通过定时备份RDB文件来实现redis数据库的备份， 
RDB文件是经过压缩的二进制文件，占用的空间会小于内存中的数据，更加利于传输。
#### RDB的优缺点
<br>1.	使用RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这个时候我们就需要根据具体的应用场景， 
通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受范围。如果数据相对来说比较重要，希望将损失降到最小，则可以使用AOF方式进行持久化
<br><br>2.	RDB可以最大化Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作， 
父进程无序执行任何磁盘I/O操作。同时这个也是一个缺点，如果数据集比较大的时候，fork可以能比较耗时，造成服务器在一段时间内停止处理客户端的请求；
### 实践
<br>修改redis.conf中的`appendonly yes`; 重启后执行对数据的变更命令， 会在bin目录下生成对应的.aof文件， aof文件中会记录所有的操作命令
<br>如下两个参数可以去对aof文件做优化
<br>auto-aof-rewrite-percentage 100表示当前aof文件大小超过上一次aof文件大小的百分之多少的时候会进行重写。如果之前没有重写过，以启动时aof文件大小为准
<br>auto-aof-rewrite-min-size 64mb限制允许重写最小aof文件大小，也就是文件大小小于64mb的时候，不需要进行优化
### AOF
<br>AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这一过程显然会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能
### 实践
<br>默认情况下Redis没有开启AOF（`appendonlyfile`）方式的持久化，可以通过`appendonly`参数启用，在redis.conf中找到 `appendonly yes`
<br>开启AOF持久化后每执行一条会更改Redis中的数据的命令后，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是`apendonly.aof`. 可以在redis.conf中的属性 `appendfilename appendonlyh.aof`修改
### aof重写的原理
<br>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，
 会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件， 并开始对新 AOF 
 文件进行追加操作。AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松
###  同步磁盘数据
<br>redis每次更改数据的时候， aof机制都会讲命令记录到aof文件，但是实际上由于操作系统的缓存机制，数据并没有实时写入到硬盘，而是进入硬盘缓存。再通过硬盘缓存机制去刷新到保存到文件
<br>`appendfsync always`每次执行写入都会进行同步 ， 这个是最安全但是是效率比较低的方式
<br>`appendfsync everysec`每一秒执行
<br>`appendfsync no`不主动进行同步操作，由操作系统去执行，这个是最快但是最不安全的方式
### aof文件损坏以后如何修复
<br>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。
<br>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：
<br><br>1.	为现有的 AOF 文件创建一个备份。
<br><br>2.	使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。
<br><br>redis-check-aof --fix
<br>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。
### RDB 和 AOF ,如何选择
<br>一般来说,如果对数据的安全性要求非常高的话，应该同时使用两种持久化功能。如果可以承受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 
快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快 。
<br>两种持久化策略可以同时使用，也可以使用其中一种。如果同时使用的话， 那么Redis重启时，会优先使用AOF文件来还原数据
<br><br>密码设置
<br>`requirepass foobaredbind`

## 原理
<br>1.	链表:实现Redis的各种功能,比如列表键、发布与订阅、满查询、监视器。
<br><br>2.	字典：使用哈希表作为底层实现。字典被用作数据库（哈希键）的底层实现。
<br><br>3.	解决键冲突： Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这样就解决了键冲突问题。
<br><br>4.	跳跃表是有序集合的底层实现之一。
<br><br>5.	整数集合是集合键的底层实现之一。（底层实现为数组）
<br><br>6.	压缩列表是列表键和哈希键的底层实现之一。
<br><br>7.	Redis的对象系统实现了基于引用计数的内存回收机制。
<br><br>8. 	Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象。当一个对象不再被使用时，该对象所占用的内存就会自动释放。
<br><br>9.	设置键的生存时间或过期时间。
<br><br>10.	当主服务器删除一个过期键之后，他会向所有从服务器发送一条DEL命令，显式地删除过期键。当Redis命令对数据库进行修改之后，服务器会根据配置项客户端发送数据库通知。
<br><br>11.	Redis服务器是一个事件驱动程序，服务器处理的事件分时间事件和文件事件两类。
<br><br>12.	客户端：Redis服务器是典型的一对多服务器程序：通过使用I/O多路复用技术实现文件事件处理器。

## 发布和订阅
<br>由PUBLISH,SUBSCRIBE,`PSUBSCRIBE`命令组成。
<br>发送到频道，订阅频道（PUBLISH <channel><message>）。
<br><br>Redis实现消息队列原理
<br>发布者和订阅者模式：发布者发送消息到队列，每个订阅者都能收到一样的消息。 
<br>生产者和消费者模式：生产者将消息放入队列，多个消费者共同监听，谁先抢到资源，谁就从队列中取走消息去处理。注意，每个消息只能最多被一个消费者接收。

## Redis事务
<br>MULTI(队列中、原子化地执行)（发起）
<br>EXEC（当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，如果事务执行中止，那么EXEC命令就会返回一个Null值）（提交）
<br>DISCARD清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。（回滚）
<br>WATCH等命令来实现事物功能。
<br>运行时错误 事务不回滚
<br><br>MULTI去开启事务
<br>EXEC去执行事务

## redis的安装
<br>1.	下载redis安装包 
<br><br>2.	`tar -zxvf` 安装包
<br><br>3.	在redis目录下 执行 make
<br><br>4.	可以通过make test测试编译状态
<br><br>5.	make install [prefix=/path]完成安装

## 命令
<br>1.  启动停止redis
<br>./redis-server ../redis.conf
<br>./redis-cli shutdown
<br>以后台进程的方式启动，修改redis.conf   `daemonize = yes`
<br><br>2.  连接到redis的命令
<br>./redis-cli -h 127.0.0.1 -p 6379
<br><br>3.  其他命令说明
<br>Redis-server 启动服务
<br>Redis-cli 访问到redis的控制台
<br>redis-benchmark 性能测试的工具
<br>redis-check-aof aof文件进行检测的工具
<br>redis-check-dump  rdb文件检查工具
<br>redis-sentinel sentinel 服务器配置

## 多数据支持
<br>默认支持16个数据库；可以理解为一个命名空间；跟关系型数据库不一样的点
<br><br>1.	redis不支持自定义数据库名词
<br><br>2.	每个数据库不能单独设置授权
<br><br>3.	每个数据库之间并不是完全隔离的。 可以通过`flushall`命令清空redis实例面的所有数据库中的数据
<br><br>通过 `select dbid`去选择不同的数据库命名空间 。 `dbid`的取值范围默认是0-15

## 使用入门
<br>1.	获得一个符合匹配规则的键名列表
<br>keys pattern  [? / * /[]]
<br>keys mic:hobby
<br><br>2.	判断一个键是否存在 ， EXISTS key 
<br><br>3.	type key 去获得这个key的数据结构类型

## 各种数据结构的使用
###  字符类型
###  散列类型
###  列表类型
###  集合类型
###  有序集合
<br>1.  字符类型
<br>一个字符类型的key默认存储的最大容量是512M
<br>赋值和取值
<br>SET key  value
<br>GET key
<br>递增数字
<br>`incr key`
<br><br>错误的演示
<br>int value= get key;
<br>value =value +1;
<br>set key value;
<br><br>key的设计
<br>对象类型:对象id:对象属性:对象子属性
<br>建议对key进行分类，同步在wiki统一管理
<br>短信重发机制
<br><br>`incryby key increment`  递增指定的整数
<br>`decr key `  原子递减
<br>append key value 向指定的key追加字符串
<br>`strlenkey`  获得key对应的value的长度
<br>`mgetkey key ...` 同时获得多个key的value
<br>`mset key value  key value  key value …`
<br>`setnx`
<br><br>2.  列表类型
<br>list, 可以存储一个有序的字符串列表
<br>`LPUSH/RPUSH`： 从左边或者右边push数据
<br>`LPUSH/RPUSH key value value …`
<br>｛17 20 19 18 16｝
<br><br>`llen num`  获得列表的长度
<br>`lrangekey  start stop`   ;  索引可以是负数， -1表示最右边的第一个元素
<br>`lrem key count value`
<br>`lset key index value`
<br>`LPOP/RPOP `: 取数据
<br>应用场景：可以用来做分布式消息队列
<br><br>3.  散列类型
<br>hash key value不支持数据类型的嵌套
<br>比较适合存储对象
<br>person
<br>age  18
<br>sex   男
<br>name mic
<br><br>`hset key field value`
<br>`hget key filed `
<br><br>`hmset key filed value ``[filed value …]`一次性设置多个值
<br>`hmget key field field …`一次性获得多个值
<br>`hgetall key`获得hash的所有信息，包括key和value
<br>`hexists key field` 判断字段是否存在。 存在返回1.不存在返回0
<br>`hincryby`
<br>`hsetnx`
<br>`hdel key field` `[field …]`删除一个或者多个字段
<br><br>4.  集合类型
<br>set跟list不一样的点。集合类型不能存在重复的数据。而且是无序的
<br>`saddkey member` `[member ...]`增加数据； 如果value已经存在，则会忽略存在的值，并且返回成功加入的元素的数量
<br>`srem key member`  删除元素
<br>`smemberskey`获得所有数据
<br><br>`sdiffkey key …`对多个集合执行差集运算
<br>`sunion`对多个集合执行并集操作,同时存在在两个集合里的所有值
<br><br>5.  有序集合
<br>`zadd key score member`
<br><br>`zrange key start stop` `[withscores]` 去获得元素。 `withscores`是可以获得元素的分数
<br>如果两个元素的score是相同的话，那么根据(0<9<A<Z<a<z) 方式从小到大
<br>网站访问的前10名。

## 分布式锁的实现
### 锁是用来解决什么问题的;
<br>1.	一个进程中的多个线程，多个线程并发访问同一个资源的时候，如何解决线程安全问题。
<br><br>2.	一个分布式架构系统中的两个模块同时去访问一个文件对文件进行读写操作
<br><br>3.	多个应用对同一条数据做修改的时候，如何保证数据的安全性
<br><br>在但进程中，我们可以用到synchronized、lock之类的同步操作去解决，但是对于分布式架构下多进程的情况下，如何做到跨进程的锁。就需要借助一些第三方手段来完成
<br><br>设计一个分布式所需要解决的问题
<br><br>分布式锁的解决方案
<br>1.	怎么去获取锁
### 数据库，通过唯一约束
```sql
lock(
     id  int(11),
     methodName  varchar(100),
     memo varchar(1000) ,
     modifyTime timestamp,
    unique key mn(method) -- 唯一约束
)
```
<br><br>获取锁的伪代码

```java
try{
    exec  insert into lock(methodName,memo) values(‘method’,’desc’);
    return true;
}Catch(DuplicateException e){
    return false;
}

```

<br><br>释放锁

```sql
delete from lock where methodName='';
```

#### 存在的需要思考的问题
<br>1.	锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁
<br><br>2.	锁是非阻塞的，数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作
<br><br>3.	锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁
### zookeeper实现分布式锁
<br>利用zookeeper的唯一节点特性或者有序临时节点特性获得最小节点作为锁. zookeeper 的实现相对简单，通过curator客户端，已经对锁的操作进行了封装
<br><br>同时写一个结点，写同一个结点watch

### zookeeper的优势
<br>1.	可靠性高、实现简单
<br><br>2.	zookeeper因为临时节点的特性，如果因为其他客户端因为异常和zookeeper连接中断了，那么节点会被删除，意味着锁会被自动释放
<br><br>3.	zookeeper本身提供了一套很好的集群方案，比较稳定
<br><br>4.	释放锁操作，会有watch通知机制，也就是服务器端会主动发送消息给客户端这个锁已经被释放了
### 基于缓存的分布式锁实现
<br>redis中有一个setNx命令，这个命令只有在key不存在的情况下为key设置值。所以可以利用这个特性来实现分布式锁的操作

## redis多路复用机制
<br>linux的内核会把所有外部设备都看作一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个 file descriptor（文件描述符）。 对于一个socket的读写也会有响应的描述符，称为`socketfd`
(socket描述符)。而IO多路复用是指内核一旦发现进程指定的一个或者多个文件描述符IO条件准备好以后就通知该进程
<br>IO多路复用又称为事件驱动，操作系统提供了一个功能，当某个socket可读或者可写的时候，它会给一个通知。 
当配合非阻塞socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据。操作系统的功能通过`select/pool/epoll/kqueue` 
之类的系统调用函数来使用，这些函数可以同时监视多个描述符的读写就绪情况，这样多个描述符的I/O操作都能在一个线程内并发交替完成，这就叫I/O多路复用，这里的复用指的是同一个线程
<br>多路复用的优势在于用户可以在一个线程内同时处理多个socket的 io请求。达到同一个线程同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到目的

## redis中使用lua脚本
### lua脚本
<br>Lua是一个高效的轻量级脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能
### 使用脚本的好处
<br>1.	减少网络开销，在Lua脚本中可以把多个命令放在同一个脚本中运行
<br><br>2.	原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说，编写脚本的过程中无需担心会出现竞态条件
<br><br>3.	复用性，客户端发送的脚本会永远存储在redis中，这意味着其他客户端可以复用这一脚本来完成同样的逻辑

## 集群
<br>复制（master、slave）

<br>节点通过握手来将其他节点添加到自己所处的集群当中。无中心节点
<br>集群中的16384个槽可以分别平均指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其他节点，
<br>集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。
<br>集群中的节点通过发送和接收消息来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FAIL。
 
### 配置过程
<br>修改11.140和11.141的redis.conf文件，增加`slaveof masterip masterport`
<br>`slaveof`192.168.11.138 6379
### 实现原理
<br>1.	slave第一次或者重连到master上以后，会向master发送一个SYNC的命令
<br><br>2.	master收到SYNC的时候，会做两件事
<br><br>a)	执行`bgsave`（rdb的快照文件）
<br><br>b)	master会把新收到的修改命令存入到缓冲区
### 缺点
<br>没有办法对master进行动态选举
<br>复制的方式
<br><br>1.	基于rdb文件的复制（第一次连接或者重连的时候）
<br><br>2.	无硬盘复制
<br><br>3.	增量复制
<br><br>`PSYNC` master run id. offset
### 哨兵机制
<br>是Redis高可用性的解决方案。一般10s每次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者Sentinel
正在对主服务器进行故障转移操作是，发送频率会改成每秒一次。每个主节点一个从节点，故障从提主。自动。基数防脑裂。
<br><br>sentinel
<br><br>1.	监控master和salve是否正常运行
<br><br>2.	如果master出现故障，那么会把其中一台salve数据升级为master
<br><br>集群（redis3.0以后的功能）
<br>根据key的hash值取模 服务器的数量 。 
<br>hash
### 集群的原理
<br>官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。
这时，如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为主节点，
整个集群继续对外提供服务。这非常类似服务器节点通过Sentinel监控架构成主从结构，只是Redis Cluster本身提供了故障转移容错的能力。
<br><br>slot（槽）的概念，在redis集群中一共会有16384个槽，
<br>根据key的CRC16算法，得到的结果再对16384进行取模。 假如有3个节点
<br>node1  0 5460
<br>node2  5461 10922
<br>node3  10923 16383
<br>节点新增
<br>node4  0-1364,5461-6826,10923-12287
<br>删除节点
<br>先将节点的数据移动到其他节点上，然后才能执行删除
### 市面上提供了集群方案
<br>1.	redis `shardding`   而且`jedis`客户端就支持`shardding`操作`SharddingJedis`； 增加和减少节点的问题； `pre shardding`
<br>3台虚拟机 redis。但是我部署了9个节点 。每一台部署3个redis增加cpu的利用率
<br>9台虚拟机单独拆分到9台服务器
<br><br>2.	`codis`基于redis2.8.13分支开发了一个`codis-server`
<br><br>3.	`twemproxy`  twitter提供的开源解决方案

## 缓存更新
<br>redis缓存的更新（2pc 3pc 强一致，但是效率低）
<br><br>1.  先删除缓存，再更新数据库(并发操作更新还没有完成，就查询，load之前错误数据到缓存，之后数据都会出现脏读)
<br><br>2.  先更新数据库，更新成功后，让缓存失效（也会出现脏读，概率低一些）
<br><br>3.  更新数据的时候，只更新缓存，不更新数据库，然后同步异步调度去批量更新数据库（性能高，数据不是强一致）

## 穿透、击穿
<br>1.  缓存穿透 布隆过滤器
<br><br>2.  缓存击穿 同时失效（随机时间） 互斥锁让请求排队等待

## C字符串，SDS
<br>比起C字符串，SDS具有以下优点:
<br><br>1)常数复杂度获取字符串长度。
<br><br>2)杜绝缓冲区溢出。
<br><br>3)减少修改字符串长度时所需的内存重分配次数。
<br><br>4)二进制安全。
<br><br>5)兼容部分C字符串函数。

**C字符串和SDS之间的区别**
|C字符串|SDS|
|:--:|:--:|
|获取字符串长度的复杂度为O(M) |  获取字符串长度的复杂度为0(1) (SDS在len属性中记录了SDS本身的长度)|
|API是不安全的，可能会造成缓冲区溢出 |  API是安全的,不会造成缓冲区溢出|
|修改字符串长度N次必然需要执行N次内存重分配只能保存文本数据 |修改字符串长度N次最多需要执行N次内存重分配可以保存文本或者二进制数据|
|可以使用所有<string .h>库中的函数   | 可以使用一部分<string.h>库中的函数|

<br>与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性:当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，
如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。

<br>C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，
程序都总要对保存这个C字符串的数组进行一次内存重分配操作
    
<br>为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联:在SDS中,  
buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。
通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。
<br><br>1. 空间预分配
<br>空间预分配用于优化SDS的字符串增长操作:  当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。
<br>eg. 如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节(额外的一字节用于保存空字符)。
<br>如果对SDS进行修改之后，SDS的长度将大于等于1MB,那么程序会分配1MB的未
使用空间。
<br>eg. 如果进行修改之后，SDS的len将变成30MB,那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB + 1MB + 1byte。
<br><br>2.  惰性空间释放
<br>执行`sdstrim`之后的SDS并没有释放多出来的8字节空间，而是将这8字节空间作为未使用空间保留在了SDS里面，如果将来要对SDS进行增长操作的话，这些未使用空间就可能会派上用场

## 链表
<br>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。
<br><br>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。
<br><br>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。
<br><br>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针,以及链表长度等信息。
<br><br>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL,所以Redis的链表实现是无环链表。
<br><br>通过为链表设置不同的类型特定函数, Redis 的链表可以用于保存各种不同类型的值。

<br>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一一个键值对。
接下来的三个小节将分别介绍Redis的哈希表、哈希表节点以及字典的实现。

## 字典
<br>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。
<br><br>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。
<br><br>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。
<br><br>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL,所以Redis的链表实现是无环链表。
<br><br>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。
<br><br>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

br>哈希算法
当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

<br>Redis的哈希表使用链地址法( separate chaining)来解央键冲突，每个哈希表节点都有一一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。

<br>键k1和k2产生冲突，而解决冲突的办法就是使用next指针将键k2和k1所在的节点连接起来

<br>rehash
<br>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子(load factor)维持在-个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。

<br>哈希表的扩展与收缩
<br>当以下条件中的任意-一个被满足时，程序会自动开始对哈希表执行扩展操作:
<br><br>1)服务器目前没有在执行`BGSAVE`命令或者`BGREWRITEAOF`命令，并且哈希表的负载因子大于等于1。
<br><br>2)服务器目前正在执行`BGSAVE`命令或者`BGREWRITEAOF`命令，并且哈希表的负载因子大于等于5。

## 跳跃表
<br> 跳跃表( `skiplist`)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。
<br><br> 跳跃表支持平均0(logN)、最坏0(M)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。
<br><br> 在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。
<br><br> Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多,又或者有序集合中元素的成员( member )是比较长的字符串时，Redis 就会使用跳跃表来作为有序集合键的底层实现。

## 整数集合
<br>整数集合( `intset`)是集合键的底层实现之一，当一个集合只包含整数值元素,并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。
<br>eg. 如果我们创建一一个 只包含五个元素的集合键，并且集合中的所有元素都是整数值，那么这个集合键的底层实现就会是整数集合

<br>整数集合是集合键的底层实现之一。
<br>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型,  改变这个数组的类型。
<br>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。整数集合只支持升级操作，不支持降级操作。

## 压缩列表
<br>压缩列表( `ziplist` )是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。
<br><br>压缩列表是一种为节约内存而开发的顺序型数据结构。压缩列表被用作列表键和哈希键的底层实现之一。
<br>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
<br>添加新节点到压缩列表,  或者从压缩列表中删除节点，可能会引发连锁更新操作,但这种操作出现的几率并不高。


## 对象
<br>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少-种我们前面所介绍的数据结构。
<br>通过这五种不同类型的对象，Redis 可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。
<br>除此之外，  Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放;另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。
<br>最后，  Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。

<br>而另一种命令只能对特定类型的键执行，比如说:
<br><br>1.  SET、GET、APPEND、`STRLEN`等命令只能对字符串键执行;
<br><br>2.  `HDEL`、`HSET`、`HGET`、`HLEN`等命令只能对哈希键执行;
<br><br>3.  `RPUSH`、`LPOP`、`LINSERT`、`LLEN`等命令只能对列表键执行;
<br><br>4.  `SADD`、`SPOP`、`SINTER`、`SCARD`等命令只能对集合键执行;
<br><br>5.  `ZADD`、`ZCARD`、`ZRANK`、 `ZSCORE`等命令只能对有序集合键执行;

<br>对象的引用计数信息会随着对象的使用状态而不断变化:
<br><br>1.  在创建一个新对象时，引用计数的值会被初始化为1;
<br><br>2.  当对象被一个新程序使用时，它的引用计数值会被增一;
<br><br>3.  当对象不再被一个程序使用时，它的引用计数值会被减一;
<br><br>4.  当对象的引用计数值变为0时，对象所占用的内存会被释放。

<br> 重点
<br><br>1.  Redis数据库中的每个键值对的键和值都是一个对象。
<br><br>2.  Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。
服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。
<br><br>3.  Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。
<br><br>4.  Redis 会共享值为0到9999的字符串对象。
<br><br>5.  对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

## 数据库
<br>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。
<br><br>通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能一这 就是SELECT命令的实现原理。
<br><br>在数次切换数据库之后，你很可能会忘记自己当前正在使用的是哪个数据库。当出现这种情况时，为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后才执行别的命令。
<br><br>键空间和用户所见的数据库是直接对应的:
<br><br>1.  键空间的键也就是数据库的键，每个键都是一个字符串对象。
<br><br>2.  键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、
集合对象和有序集合对象中的任意一种Redis对象。

<br>数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的

<br>读写键空间时的维护操作
<br>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作,还会执行一些额外的维护操作，其中包括:
<br><br>1.  在读取一个键之后(读操作和写操作都要对键进行读取),服务器会根据键是否存在来更新服务器的键空间命中( hit)次数或键空间不命中( miss)次数， 这两个值可以在INFO stats命令的keyspace_ hits 
属性和keyspace_misses属性中查看。
在读取一个键之后，服务器会更新键的LRU (最后一次使用)时间，这个值可以用于计算键的闲置时间,使用OBJECT `idletime` <key>命令可以查看键key的闲置时间。
如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。
<br><br>2.  如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏(dirty),从而让事务程序注意到这个键已经被修改过。
<br><br>3.  服务器每次修改一个键之后，都会对脏( `dity` )键计数器的值增1,这个计数器会触发服务器的持久化以及复制操作。
<br><br>4.  如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知，本章稍后讨论数据库通知功能的实现时会详细说明这一点。
<br><br>`SETEX`命令可以在设置一个字符串键的同时为键设置过期时间，因为这个命令是一个类型限定的命令(只能用于字符串键),所以本章不会对这个命令进行介绍，但`SETEX`命令设置过期时间的原理和本章介绍的EXPIRE命令设置过期时间的原理是完全一样的。
与EXPIRE命令和`PEXPIRE`命令类似，客户端可以通过`EXPIREAT`命令或`PEXPIREAT`命令,以秒或者毫秒精度给数据库中的某个键设置过期时间( expire time )。

<br>设置过期时间
<br>Redis有四个不同的命令可以用于设置键的生存时间(键可以存在多久)或过期时间(键什么时候会被删除):
<br><br>1.  `EXPIRE` <key> <tl>命令用于将键key的生存时间设置为ttl秒。
<br><br>2.  `PEXPIRE` <key> <ttl>命令用于将键key的生存时间设置为ttl毫秒。
<br><br>3.  `EXPIREAT` <key> <timestamp> 命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。
<br><br>4.  `PEXPIREAT` <key> <timestamp> 命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。
<br><br>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、`PEXPIRE`、 
`EXPIREAT`三个命令都是使用`PEXPIREAT`命令来实现的:无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行`PEXPIREAT`命令一样。
<br><br>PERSIST命令就是`PEXPIREAT`命令的反操作: PERSIST命令在过期字典中查找给定的键、并解除键和值(过期时间)在过期字典中的关联。
<br><br>计算并返回剩余生存时间
<br>TTL命令以秒为单位返回键的剩余生存时间，而`PTTL`命令则以毫秒为单位返回键的剩余牛存时间。

<br>过期键的判定
<br>通过过期字典，程序可以用以下步骤检查-个给定键是否过期:
<br><br>1)检查给定键是否存在于过期字典:  如果存在，那么取得键的过期时间。
<br><br>2)检查当前UNIX时间截是否大于键的过期时间:如果是的话，那么键已经过期;否则的话，键未过期。
<br><br>实现过期键判定的另一种方法是使用TTL命令或者`PTTL`命令，  比如说，如果对某个键执行TTL命令，并且命令返回的值大于等于0，那么说明该键未过期。在实际中，Redis 检查键是否过期的方法和is_expired 函数所描述的方法一致，因为直接访问字典比执行一个命令稍微快一些。

<br>实现过期键判定的另一种方法是使用TTL命令或者`PTTL`命令，  比如说，如果对某个键执行TTL命令，并且命令返回的值大于等于0，那么说明该键未过期。在实际中，Redis 检查键是否过期的方法和is_expired 函数所描述的方法一致，因为直接访问字典比执行一个命令稍微快一些。     

<br>键空间和用户所见的数据库是直接对应的: 
<br>键空间的键也就是数据库的键，每个键都是一个字符串对象。
<br>键空间的值也就是数据库的值，  每个值可以是字符串对象、列表对象、哈希表对象、
<br>集合对象和有序集合对象中的任意一种Redis对象。

<br>过期键删除策略
<br>经过上一节的介绍，我们知道了数据库键的过期时间都保存在过期字典中，又知道了如何根据过期时间去判断一个键是否过期，现在剩下的问题是:如果一个键过期了,那么它什么时候会被删除呢?
<br>这个问题有三种可能的答案，它们分别代表了三种不同的删除策略: 
<br><br>1.  定时删除:在设置键的过期时间的同时，创建一个定时器( timer ),让定时器在键的过期时间来临时，立即执行对键的删除操作。
<br><br>2.  惰性删除:放任键过期不管,但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
<br><br>3.  定期删除:每隔一段时间，程序就对数据库进行-次检查,删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。
<br>在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。

br>定时删除策略对内存是最友好的:通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。
<br>另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的:在过期键比较多的

<br>惰性删除策略对CPU时间来说是最友好的:程序只会在取出键时才对键进行过期检查,这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。
<br>惰性删除策略的缺点是，它对内存是最不友好的:如果-一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。

<br>定期删除
<br>从上面对定时删除和惰性删除的讨论来看,这两种删除方式在单-使用时都有明显的缺陷: 口定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。0惰性删除浪费太多内存，有内存泄漏的危险。定期删除策略是前两种策略的一种整合和折中:
<br><br>1.  定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
<br><br>2.  除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。
 <br><br>定期删除策略的难点是确定删除操作执行的时长和频率:
<br><br>1.  如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。
<br><br>2.  如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。
因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。 
 
<br>AOF、 RDB和复制功能对过期键的处理
<br>生成RDB文件在执行SAVE命令或者`BGSAVE`命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。
<br>eg，如果数据库中包含三个键k1、k2、k3，并且k2已经过期，那么当执行SAVE命令或者`BGSAVE`命令时，程序只会将k1和k3的数据保存到RDB文件中，而k2则会被忽略。
<br>因此，数据库中包含过期键不会对生成新的RDB文件造成影响。
<br>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载人:
<br>如果服务器以主服务器模式运行，那么在载人RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载人到数据库中，而过期键则会被忽略，所以过期键对载人RDB文件的主服务器不会造成影响。
<br>如果服务器以从服务器模式运行，那么在载人RDB文件时，文件中保存的所有键，不论是否过期，都会被载人到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载人RDB文件的从服务器也不会造成影响。
<br>eg.  如果数据库中包含三个键k1、k2、k3,并且k2已经过期，那么当服务器启动时:
<br>如果服务器以主服务器模式运行，那么程序只会将k1和k3载人到数据库，k2会被忽略。
<br>如果服务器以从服务器模式运行，那么k1、k2和k3都会被载人到数据库。
 
<br> AOF文件写入当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。
<br>当过期键 鼓惰性删除或者定期删除之后，程序会向AOF文件追加( append)一条DEL命令，来显式地记录该键已被删除。
<br>eg.  如果客户端使用GET message 命令，试图访问过期的message键，那么服务器将执行以下三个动作:
<br><br>1.  从数据库中删除message键。
<br><br>2.  追加一条DEL message 命令到AOF文件。
<br><br>3.  向执行GET命令的客户端返回空回复。

<br>AOF重写
<br>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。
<br>eg.  如果数据库中包含三个键k1、k2、k3,并且k2已经过期，那么在进行重写工作时，程序只会对k1和k3进行重写，而k2则会被忽略。
<br>因此，数据库中包含过期键不会对AOF重写造成影响。

<br>复制
<br>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制:
<br><br>1.  主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。
<br><br>2.  从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键-样来处理过期键。
<br><br>3.  从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。

<br>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。
<br>eg.  有一对主从服务器，它们的数据库中都保存着同样的三个键message.xxx和YYY,  其中message为过期键。
<br><br>如果这时有客，户端向从服务器发送命令GET  message,那么从服务器将发现`rmessage`键已经过期，但从服务器并不会删除message键，  而是继续将message键的值返回给客户端，就好像message键并没有过期一样
<br>假设在此之后，有客户端向主服务器发送命令GET message,那么主服务器将发现键message已经过期:主服务器会删除message键，  向客户端返回空回复，并向从服务器发送DEL  message命令
<br>从服务器在接收到主服务器发来的DEL  message命令之后，也会从数据库中删除message键，在这之后，主从服务器都不再保存过期键message了

<br>重点
<br><br>1.  Redis 服务器的所有数据车都保存在redisServer.db数组中，而数据库的数量则由redisServer.db num属性保存。
<br><br>2.  客户端通过修改目标数据库指针，让它指向`redisserver` . db数组中的不同元素来切换不同的数据库。
<br><br>3.  数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对,而expires字典则负责保存键的过期时间。
<br><br>4.  因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。
<br><br>5.  数据库的键总是一个字符串对象，而值则可以是任意-种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。
<br><br>6.  expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。
<br><br>7.  Redis 使用惰性删除和定期删除两种策略来删除过期的键:惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔-段时间主动查找并删除过期键。
<br><br>8.  执行SAVE命令或者`BGSAVE`命令所产生的新RDB文件不会包含已经过期的键。0执行`BGREWRITEAOF`命令所产生的重写AOF文件不会包含已经过期的键。
<br><br>9.  当一个过期键被删除之后， 服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。
<br><br>10.  当主服务器刪除-一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。
<br><br>11.  从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令,这种统一中心化的过期键删除策略可以保证主从服务器数据的一致性。
<br><br>12.  当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。

## RDB、AOF
<br>另外值得一提的是， 因为AOF文件的更新频率通常比RDB文件的更新频率高，所以:口如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。
只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。

<br>dirty计数器和`lastsave`属性
<br>除了`saveparams`数组之外，服务器状态还维持着-一个dirty计数器，以及一个`lastsave`属性:
dirty 计数器记录距离.上一次成功执行 SAVE命令或者`BGSAVE`命令之后，服务器
对数据库状态(服务器中的所有数据库)进行了多少次修改(包括写人、删除、更新等操作)。
`lastsave`属性是一个UNIX时间戳，记录了服务器.上一次成功执行SAVE命令或者`BGSAVE`命令的时间。
<br>当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新:命令修改了多少次数据库，dirty计数器的值就增加多少。

<br>检查保存条件是否满足
<br>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中-项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。

<br>**注意**
<br>因为RDB文件保存的是二进制数据，而不是C字符串，为了简便起见，我们用"REDIS"符号代表'R'、 'E'、'D'、'I'、  'S '五个字符，而不是带'\0'结尾符号的C字符串'R'、'E'、 'D'、 'I'、 'S'、 '\0'。 本章介绍的所有内容，  以及展示的所有RDB文件结构图都遵循这一規则。

<br>重点
<br><br>1.  RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。口SAVE 命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。
<br><br>2.  `BGSAVE`令由子进程执行保存操作，所以该命令不会阻塞服务器。
<br><br>3.  服务器状态中会保存所有用save选项设置的保存条件，当任意-一个保存条件被满足时，服务器会自动执行`BGSAVE`命令。
<br><br>4.  RDB文件是一个经过压缩的二进制文件，由多个部分组成。
<br><br>5.  对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。

<br>AOF持久化的效率和安全性
<br><br>服务器配置`appendfsync`选项的值直接决定AOF持久化功能的效率和安全性。当`appendfsync`的值为always时，服务器在每个事件循环都要将aof_buf 缓冲区中的所有内容写入到AOF文件,
并且同步AOF文件,
<br><br>所以always的效率是`appendfsync`选项三个值当中最慢的一个，但从安全性来说，always 也是最安全的，因为即使出现故障停机, AOF持久化也只会丢失一个事件循环中所产生的命令数据。
<br><br>当`appendfsync`的值为`everysec`时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。从效率上来讲，`everysec` 模式足够快，并且就算出现故障停机,数据库也只丢失一秒钟的命令数据。
<br><br>当`appendfsync`的值为no时，服务器在每个事件循环都要将aof_ buf 缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。 
<br><br>因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的， 
不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看， no模式和`everysec`模式的效率类似，当出现故障停机时， 
使用no模式的服务哭将丢失上次同步AOF文件之后的所有写命今数据。
<br><br>这也就是说，  在子进程执行AOF重写期间，服务器进程需要执行以下三个工作:
<br><br>1.  执行客户端发来的命令。
<br><br>2.  将执行后的写命令追加到AOF缓冲区。
<br><br>3.  将执行后的写命令追加到AOF重写缓冲区。

<br>这样一来可以保证:
<br><br>1.  AOF缓冲区的内容会定期被写人和同步到AOF文件，对现有AOF文件的处理工作会如常进行。
<br><br>2.  从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。当子进程完成AOF重写工作之后，它会向父进程发送一个信号,父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作:
<br><br>1)将AOF重写缓冲区中的所有内容写人到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。
<br><br>2)对新的AOF文件进行改名，原子地( atomic)覆盖现有的AOF文件，完成新旧两个AOF文件的替换。
<br><br>这个信号处理函数执行完毕之后，父进程就可以继续像往常-样接受命令请求了。
<br><br>在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程(父进程)造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。

<br>重点
<br><br>1.  AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。口AOF文件中的所有命令都以Redis命令请求协议的格式保存。
<br><br>2.  命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。
<br><br>3.  `appendfsync` 选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。
<br><br>4.  服务器只要载人并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。口AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。
<br><br>5.  AOF重写是-一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读人、分析或者写人操作。
<br><br>6.  在执行`BGREWRITEAOF`命令时，  Redis服务器会维护-个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。 
<br><br>当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾， 使得新旧两个AOF文件所保存的数据库状态一致。 
<br><br>最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。

## 事件
<br>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件:
<br><br>1.  文件事件( file event); Redis 服务器通过套接字与客户端(或者其他Redis服务器)
<br>进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端(或者其他服务器)的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。
<br><br>2.  时间事件( time event): Redis 服务器中的- -些操作(比如serverCron函数)需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。

<br>文件事件
<br>Redis基于Reactor模式开发了自己的网络事件处理器:这个处理器被称为文件事件处理器( file event handler ) :
<br><br>1.  文件事件处理器使用I/O多路复用( multiplexing )程序来同时监听多个套接字，并
<br>根据套接字目前执行的任务来为套接字关联不同的事件处理器。
<br><br>2.  当被监听的套接字准备好执行连接应答( accept)、 读取(read) 写人(write)、关
闭( close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。
<br>虽然文件事件处理器以单线程方式运行，但通过使用IO多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis 内部单线程设计的简单性。

<br>时间事件
<br>Redis的时间事件分为以下两类:
<br><br>1.  定时事件:让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行-一次。
<br><br>2.  周期性事件:让-段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。

<br>一个时间事件主要由以下三个属性组成:
<br><br>1.  id:服务器为时间事件创建的全局唯一ID (标识号)。ID号按从小到大的顺序递增,新事件的D号比旧事件的ID号要大。
<br><br>2.  when: 毫秒精度的UNIX时间截，记录了时间事件的到达( arrive)时间。
<br><br>3.  timeProc: 时间事件处理器，-个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。

<br>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:
<br><br>1.  如果事件处理器返回`ae.h/AE_NOMORE`,那么这个事件为定时事件:该事件在达到一次之后就会被删除，之后不再到达。
<br><br>2.  如果事件处理器返回一个非`AE_NOMORE`的整数值，那么这个事件为周期性时间:

<br>当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30,
那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。

<br>以下是事件的调度和执行规则:
<br><br>1.  aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询(忙等待),也可以确保aeApiPoll函数不会阻塞过长时间。
<br><br>2.  因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。 
随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。
<br><br>3.  对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器， 
还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说， 
在命令回复处理器将一个命令回复写人到客户端套接字时，如果写人字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，
将余下的数据留到下次再写;另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。
<br><br>4.  因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。

<br><br>重点
<br><br>1.  Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。口文件事件处理器是基于Reactor模式实现的网络通信程序。
<br><br>2.  文件事件是对套接字操作的抽象:每次套接字变为可应答( acceptable)、 可写( writable)或者可读( readable)时，相应的文件事件就会产生。
<br><br>3.  文件事件分为AE_READABLE事件(读事件)和AE WRITABLE事件(写事件)两类。口时间事件分为定时事件和周期性事件:定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。
<br><br>4.  服务器在一般情况下只执行serverCron函数-个时间事件，并且这个事件是周期性事件。
<br><br>5.  文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。
<br><br>6.  时间事件的实际处理时间通常会比设定的到达时间晚一些。

## 客户端
<br>1.  服务器状态结构使用clients链表连接起多个客户端状态,新添加的客户端状态会被放到链表的末尾。
<br><br>2.  客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。
<br><br>3.  输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1 GB。
<br><br>4.  命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。
<br><br>5.  客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16 KB,而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。
<br><br>6.  输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭;除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。
<br><br>7.  当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。  网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT 
KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。
<br><br>8.  处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会-直存在，直到服务器关闭。
<br><br>9.  载人AOF文件时使用的伪客户端在载人工作开始时动态创建，载人工作完毕之后关闭。

## 服务端
<br>1.  一个命令请求从发送到完成主要包括以下步骤: 
<br><br>1) 客户端将命令请求发送给服务器;
<br><br>2) 服务器读取命令请求，并分析出命令参数; 
<br><br>3) 命令执行器根据参数查找命令的实现函数,然后执行实现函数并得出命令回复; 
<br><br>4) 服务器将命令回复返回给客户端。serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。

<br>2.  服务器从启动到能够处理客户端的命令请求需要执行以下步骤:
<br><br>1) 初始化服务器状态; 
<br><br>2) 载人服务器配置; 
<br><br>3) 初始化服务器数据结构; 
<br><br>4) 还原数据库状态; 
<br><br>5) 执行事件循环。

## 复制
<br>SYNC命令是一个非常耗费资源的操作每次执行SYNC命令，主从服务器需要执行以下动作:
<br><br>1.  主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘IO资源。
<br><br>2.  主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源( 带宽和流量),并对主服务器响应命令请求的时间产生影响。
<br><br>3.  接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。
<br><br>因为SYNC命令是一个如此耗费资源的操作，所以Redis有必要保证在真正有需要时才执行SYNC命令。

<br>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用`PSYNC`命令代替SYNC命令来执行复制时的同步操作。
<br>`PSYNC`命令具有完整重同步( full resynchronization)和部分重同步( partial resynchronization)两种模式:
<br><br>1.  其中完整重同步用于处理初次复制情况:完整重同步的执行步骤和SYNC命令的执行步骤基本-样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
<br><br>2.  而部分重同步则用于处理断线后重复制情况:当从服务器在断线后重新连接主服务器时，如果条件允许,主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。
<br><br>`PSYNC`命令的部分重同步模式解决了旧版复制功能在处理断线后重复制时出现的低效

<br>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态:
<br><br>1.  如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的。相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态。
<br><br>2.  Redis 2.8以前的复制功能不能高效地处理断线后重复制情况，但Redis 2.8新添加的部分重同步功能可以解决这个问题。
<br><br>3.  部分重同步通过复制偏移量、复制积压缓冲区、服务器运行ID三个部分来实现。口在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。
<br><br>4.  主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器发送命令来进行心跳检测,以及命令丢失检测。

## Sentinel
<br>1.  Sentinel 只是一个运行在特殊模式下的Redis服务器，它使用了和普通模式不同的命令表，所以Sentinel模式能够使用的命令和普通Redis服务器能够使用的命令不同。Sentinel 会读人用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，其中命令连接用于向主服务器发送命令请求，而订阅连接则用于接收指定频道的消息。
<br><br>2.  Sentinel通过向主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。
<br><br>3.  在一般情况下，Sentinel以每十秒一次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者Sentinel正在对主服务器进行故障转移操作时，Sentinel 向从服务器发送INFO命令的频率会改为每秒一次。
<br><br>4.  对于监视同一个主服务器和从服务器的多个Sentinel来说，它们会以每两秒--次的频率，通过向被监视服务器的_sentinel_ : hello频道发送消息来向其他Sentinel宣告自己的存在。 
每个Sentinel也会从_sentinel_ : hello频道中接收其他Sentinel发来的信息，并根据这些信息为其他Sentinel创建相应的实例结构，以及命令连接。
<br><br>5.  Sentinel只会与主服务器和从服务器创建命令连接和订阅连接，Sentinel与Sentinel之间则只创建命令连接。
<br><br>6.  Sentinel 以每秒- -次的频率向实例(包括主服务器、从服务器、其他Sentinel)
发送PING命令，并根据实例对PING命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向Sentinel发送无效回复时，Sentinel  
会将这个实例判断为主观下线。
<br><br>7.  当Sentinel将-一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其他Sentinel进行询问，看它们是否同意这个主服务器已经进入主观下线状态。
<br><br>8.  当Sentinel收集到足够多的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。

## 集群
<br>1.  节点通过握手来将其他节点添加到自己所处的集群当中。
<br><br>2.  集群中的16384个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其他节点。
<br><br>3.  节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个MOVED错误，MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。
<br><br>4.  对Redis集群的重新分片工作是由redis-trib 负责执行的，重新分片的关键是将属于某个槽的所有键值对从-个节点转移至另一个节点。
<br><br>5.  如果节点A正在迁移槽i至节点B,那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个ASK错误，指引客户端到节点B继续查找指定的数据库键。
<br><br>6.  MOVED错误表示槽的负责权已经从一个节点转移到了另一个节点，而ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施。
<br><br>7.  集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。
<br><br>8.  集群中的节点通过发送和接收消息来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FAIL五种。

## 发布与订阅
<br>Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、 `PSUBSCRIBE`等命令组成。
<br>通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者( subscriber):每当有其他客户端向被订阅的频道发送消息( message)时，频道的所有订阅者都会收到这条消息。

<br><br>1.  服务器状态在`pubsub_channels`字典保存了所有频道的订阅关系: SUBSCRIBE 命令负责将客户端和被订阅的频道关联到这个字典里面，而UNSUBSCRIBE命令则负责解除客户端和被退订频道之间的关联。
<br><br>2.  服务器状态在`pubsub_ patterns`链表保存了所有模式的订阅关系: `PSUBSCRIBE`命令负责将客户端和被订阅的模式记录到这个链表中，而`PUNSUBSCRIBE`命令则负责移除客户端和被退订模式在链表中的记录。
<br><br>3.  PUBLISH命令通过访问`pubsub_channels` 字典来向频道的所有订阅者发送消息，通过访问`pubsub_patterns`链表来向所有匹配频道的模式的订阅者发送消息。
<br><br>4.  `0PUBSUB`命令的三个子命令都是通过读取`pubsub_channels`字典和`pubsub_patterns`链表中的信息来实现的。

## 事务
<br>Redis通过MULTI、EXEC、WATCH等命令来实现事务( transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、
按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，
然后才去处理其他客户端的命令请求。

<br><br>1.  事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。
<br><br>2.  多个命令会被人队到事务队列中，然后按先进先出( FIFO )的顺序执行。
<br><br>3.  事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。
<br><br>4.  带有WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，当键被修改时,程序会将所有监视被修改键的客户端的REDIS_DIRTY_CAS 标志打开。
<br><br>5.  只有在客户端的REDIS_DIRTY_CAS 标志未被打开时,服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务。
<br><br>6.  Redis 的事务总是具有ACID中的原子性、一致性和隔离性，当服务器运行在AOF持久化模式下，并且`appendfsync`选项的值为always时，事务也具有耐久性。

## Lua脚本
<br>1.  Redis服务器在启动时，会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足Redis在功能性、安全性等方面的需要。
<br><br>2.  Redis服务器专门使用一个伪客户端来执行Lua脚本中包含的Redis命令。
<br><br>3.  Redis使用脚本字典来保存所有被EVAL命令执行过，或者被SCRIPT LOAD命令载入过的Lua脚本，这些脚本可以用于实现SCRIPT EXISTS命令，以及实现脚本复制功能。
<br><br>4.  EVAL命令为客户端输人的脚本在Lua环境中定义一个函数，并通过调用这个函数来执行脚本。
<br><br>5.  `EVALSHA`命令通过直接调用Lua环境中已定义的函数来执行脚本。
<br><br>6.  SCRIPT FLUSH命令会清空服务器lua_ scripts 字典中保存的脚本，并重置Lua环境。
<br><br>7.  SCRIPT EXISTS命令接受一个或多个SHA1校验和为参数，并通过检查lua_scripts字典来确认校验和对应的脚本是否存在。
<br><br>8.  SCRIPT LOAD命令接受-一个Lua脚本为参数，为该脚本在Lua环境中创建函数,并将脚本保存到lua_scripts 字典中。
<br><br>9.  服务器在执行脚本之前，会为Lua环境设置一个超时处理钩子，当脚本出现超时运行情况时，客户端可以通过向服务器发送SCRIPT KILL命令来让钩子停止正在执行的脚本，或者发送`SHUTDOWN nosave`命令来让钩子关闭整个服务器。
<br><br>10.  主服务器复制EVAL、SCRIPT FLUSH、SCRIPT LOAD三个命令的方法和复制普通Redis命令-一样，只要将相同的命令传播给从服务器就可以了。
<br><br>11.  主服务器在复制`EVALSHA`命令时，必须确保所有从服务器都已经载人了`EVALSHA`命令指定的SHA1校验和所对应的Lua脚本，如果不能确保这一点的话，主服务器会将`EVALSHA`命令转换成等效的EVAL命令，并通过传播EVAL命令来获得相同的

## 排序
<br>1.  SORT命令通过将被排序键包含的元素载人到数组里面，然后对数组进行排序来完成对键进行排序的工作。
<br><br>2.  在默认情况下，SORT命令假设被排序键包含的都是数字值，并且以数字值的方式来进行排序。
<br><br>3.  如果SORT命令使用了ALPHA选项，那么SORT命令假设被排序键包含的都是字符串值，并且以字符串的方式来进行排序。
<br><br>4.  SORT命令的排序操作由快速排序算法实现。
<br><br>5.  SORT命令会根据用户是否使用了DESC选项来决定是使用升序对比还是降序对比来比较被排序的元素，升序对比会产生升序排序结果，被排序的元素按值的大小从小到大排列，降序对比会产生降序排序结果，被排序的元素按值的大小从大到小排列。口当SORT命令使用了BY选项时，命令使用其他键的值作为权重来进行排序操作。口当SORT命令使用了LIMIT选项时，命令只保留排序结果集中LIMIT选项指定的元素。
<br><br>6.  当SORT命令使用了GET选项时，命令会根据排序结果集中的元素，以及GET选项给定的模式，查找并返回其他键的值，而不是返回被排序的元素。
<br><br>7.  当SORT命令使用了STORE选项时，命令会将排序结果集保存在指定的键里面。
<br><br>8.  当SORT命令同时使用多个选项时，命令先执行排序操作(可用的选项为ALPHA、ASC或DESC、BY)，然后执行LIMIT选项，之后执行GET选项，再之后执行STORE选项，最后才将排序结果集返回给客户端。
<br><br>9.  除了GET选项之外，调整选项的摆放位置不会影响SORT命令的排序结果。

## 二进制数组
<br>1.  Redis使用SDS来保存位数组。
<br><br>2.  SDS使用逆序来保存位数组，这种保存顺序简化了`SETBIT`命令的实现，使得`SETBIT`命令可以在不移动现有二进制位的情况下，对位数组进行空间扩展。
<br><br>3.  BITCOUNT命令使用了查表算法和variable-precision `SWAR`算法来优化命令的执行效率。
<br><br>4.  `BITOP`命令的所有操作都使用C语言内置的位操作来实现。

## 慢查询日志
<br>1.  Redis 的慢查询日志功能用于记录执行时间超过指定时长的命令。
<br><br>2.  Redis服务器将所有的慢查询日志保存在服务器状态的`slowlog`链表中，每个链表节点都包含一个 `slowlogEntry`结构，每个`slowlogEntry`结构代表一条慢查询日志。
<br><br>3.  打印和删除慢查询日志可以通过遍历`slowlog`链表来完成。
<br><br>4.  `slowlog`链表的长度就是服务器所保存慢查询日志的数量。
<br><br>5.  新的慢查询日志会被添加到`slowlog`链表的表头，如果日志的数量超过`slowlog-max-len`选项的值，那么多出来的日志会被删除。

## 监视器
<br>1.  客户端可以通过执行MONITOR命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息。
<br><br>2.  当一个客户端从普通客户端变为监视器时，该客户端的REDIS_MONITOR 标识会被打开。
<br><br>3.  服务器将所有监视器都记录在monitors链表中。
<br><br>4.  每次处理命令请求时，服务器都会遍历monitors链表，将相关信息发送给监视器。








































