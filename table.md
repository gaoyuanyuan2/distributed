## 分库分表及Mycat
### 1、为什么要分库分表
<br> 超大容量问题
<br> 性能问题
<br> 如何去做到
<br> <br> 垂直切分、 水平切分
<br> <br> 1.	垂直分库； 解决的是表过多的问题
<br> <br> 2.	垂直分表； 解决单表列过多的问题
<br> <br> 水平切分； 大数据表拆成小表
<br> 常见的拆分策略
<br> 垂直拆分（er分片）
<br> <br> 水平拆分
<br> 一致性hash
<br> 范围切分 可以按照ID
<br> 日期拆分

### 2、拆分以后带来的问题
#### 跨库join的问题
<br> 1.	设计的时候考虑到应用层的join问题。
<br> <br> 2.	在服务层去做调用；
<br><br>A服务里查询到一个list
<br><br>3.	全局表
<br>数据变更比较少的基于全局应用的表
<br><br>4.	做字段冗余（空间换时间的做法）
<br>订单表。 商家id  商家名称
<br>商家名称变更- 定时任务、任务通知

#### 跨分片数据排序分页
#### 唯一主键问题
<br>用自增id做主键
<br>UUID 性能比较低
<br>snowflake 
<br>mongoDB 
<br>zookeeper 
<br>数据库表

#### 分布式事务问题
<br><br>多个数据库表之间保证原子性  性能问题； 互联网公司用强一致性分布式事务比较少
<br><br><br>分库分表最难的在于业务的复杂度； 
<br><br>前提： 水平分表的前提是已经存在大量的业务数据。而这个业务数据已经渗透到了各个应用节点

#### 如何权衡当前公司的存储需要优化
<br>1．	提前规划（主键问题解决、 join问题）
<br>2．	当前数据单表超过1000W、每天的增长量持续上升

### 3、Mysql的主从

#### 主从同步的原理
<br>1.	master记录二进制日志。在每个事务更新数据完成之前，master在二日志记录这些改变。MySQL将事务串行的写入二进制日志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，master通知存储引擎提交事务
<br><br>2.	slave将master的binary log拷贝到它自己的中继日志。首先，slave开始一个工作线程——I/O线程。I/O线程在master上打开一个普通的连接，然后开始binlog dump process。Binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中继日志
<br><br>3.	SQL线程从中继日志读取事件，并重放其中的事件而更新slave的数据，使其与master中的数据一致

#### 主从同步的延时问题
<br>主从同步延迟是怎么产生的
<br><br>1.	当master库tps比较高的时候，产生的DDL数量超过slave一个sql线程所能承受的范围，或者slave的大型query语句产生锁等待
<br><br>2.	网络传输： bin文件的传输延迟
<br><br>3.	磁盘的读写耗时：文件通知更新、磁盘读取延迟、磁盘写入延迟
#### 解决方案
<br>1.	在数据库和应用层增加缓存处理，优先从缓存中读取数据
<br><br>2.	减少slave同步延迟，可以修改slave库sync_binlog属性； 
<br>sync_binlog=0  文件系统来调度把binlog_cache刷新到磁盘
<br>sync_binlog=n  
<br><br>3.	增加延时监控
<br>Nagios做网络监控
<br>mk-heartbeat







