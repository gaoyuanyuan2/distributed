## SpringCloud
### 1、概述
<br>1. 定义
<br>就目前而言，对于微服务业界并没有一个统一的标准的定义(While there is no precise definition of this architectural style)
<br><br>但通常而言，微服务架构是一 种架构模式或者说是一种架构风格，它提倡将单-应用程序划分成一组小的服务， 每个服务运行在其独立的自己的进程中，服务之间互相协调、
互相配合,为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通
(通常是基于HTTP的RESTful API)。每个服务都围绕着具体业务进行构建，
并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、 集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，
可以有一个非常轻量级的集中式管理来协调这些服务， 可以使用不同的语言来编写服务，也可以使用不同的数据存储。
微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合每一个微服务提供单个业务功能的服务，一个服务做一件事,
从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁,  拥有自己独立的数据库。
<br><br>简而言之，微服务架构风格是一种将单个应用程序作为一套`小型服务`开发的方法，每种应用程序都运行在自己的`进程`中，并与`轻量级`机制(通常是`HTTP资源API`)
进行通信。这些服务是围绕业务功能构建的，可以通过全自动部署机制`独立部署`，这些服务的集中管理最少，可以用不同的编程语言编写如并使用不同的数据存储技术。
<br><br>2. 优点
<br>每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求开发简单、开发效率提高，一个服务可能就是专一的只干一件事。
<br>微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。
<br>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。微服务能使用不同的语言开发。
<br>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, Hudson, bamboo微服务易于被一个开发人员理解， 修改和维护,这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。微服务允许你利用融合最新技术。
<br>微服务只是业务逻辑的代码，不会和HTML,CSS或其他界面组件混合。
<br>每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。
<br><br>3. 缺点
<br> 开发人员要处理分布式系统的复杂性
<br> 多服务运维难度，随着服务的增加，运维的压力也在增大系统部署依赖服务间通信成本数据一致性系统集成测试性能监控.....
<br><br>
![对比](https://github.com/gaoyuanyuan2/distributed/blob/master/img/16.png) 
<br><br>
![对比](https://github.com/gaoyuanyuan2/distributed/blob/master/img/17.png) 
<br><br>
<br>4. SpringCloud和SpringBoot是什么关系
<br>SpringCloud,基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。
<br>SpringCloud利用SpringBoot的开发便利性巧妙地简化了分布式系统基础设施的开发，SpringCloud为开发人员提供 了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等,它们都可以用SpringBoot的开发风格做到-键启动和部署。
<br><br>SpringBoot并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过
<br>SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包
<br><br>SpringBoot专注于快速方便的开发单个个体微服务。
SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一 个个单体微服务整合并管理起来,
为各个微服务之间提供，配置管理、服务发现、断路器、  路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务
<br><br>SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot, 属于依赖的关系
<br>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。
<br><br>5.最大区别: SpringCloud抛弃 了Dubbo的RPC通信，采用的是基于HTTP的REST方式。
<br><br> 严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约, 
不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。
<br><br>品牌机与组装机的区别
<br><br>社区支持与更新力度
<br><br>最为重要的是，DUBBO停止了5年左右的更新，虽然2017.7重启了。对于技术发展的新需求,需要由开发者自行拓展升级(比如当当网弄出了DubboX)，这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的，中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案,并不是每一个公司都有阿里的大牛 +真实的线上生产环境测试过。
<br><br> Dubbo的定位始终是一款RPC框架，而Spring Cloud的目标是微服务架构下的一站式解决方案。
<br><br>在面临微服务基础框架选型时Dubbo与Spring Cloud是只能二选一
### 2、配置管理
#### 配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置
<br> 1.将值存放在缓存中，数据库中备份。
<br><br> 2.后台搭建一套可视化管理配置文件项目。
<br><br> 3.读取流程先从缓存中读取，緩存没有在读取数据库。4.缓存与数据库值不同步怎么解决，清理缓存。
<br><br> 4.将配置文件信息，存放在版本控制(git、svn)
### 3、分布式事务
### 4、接口网关
### Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。
<br>Zuul包含了对请求的路由和过滤两个最主要的功能:
<br>其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤器 功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。
Zuul和Eureka进行整合, 将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。
<br><br>注意: Zuul服务最终还是会注册进Eureka
<br>提供=代理+路由+过滤 三大功能
<br><br>可以解决跨域问题
### 5、Eureka 服务发现、服务注册
#### 云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。(物业公司)
![](https://github.com/gaoyuanyuan2/distributed/blob/master/img/19.png) 
<br><br>1. Eureka是什么
<br><br>1) Eureka是Netflix的一个子模块，也是核心模块之一。Eureka是一 个基于`HTTP REST`的服务，用于定位服务，以实现云端中间层服务发现和故障转移。
<br>服务注册与发现对于微服务架构来说是非常重要的，有了服务发现与注册，只需要使用`服务的标识符`，就可以访问到服务，而不需要修改服务调用的配置文件了。功能类似于dubbo的注册中心，比如Zookeeper。
<br><br>2) Spring Cloud封装了Netflix 公司开发的Eureka模块来实现服务注册和发现(请对比Zookeeper)。
<br>Eureka采用了C-S的设计架构。Eureka Server作为服务注册功能的服务器，它是服务注册中心。
<br><br>3) 而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行。SpringCloud 的一些其他模块
(比如Zuul) 就可以通过Eureka Server来发现系统中的其他微服务，并执行相关的逻辑。
<br><br>2. Eureka包含两个组件: Eureka Server和Eureka Client 
<br><br>1) Eureka Server提供服务注册服务
<br><br>各个节点启动后，会在EurekaServer中进行注册， 这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。
EurekaClient是一个Java客户端， 用于简化Eureka Server的交互，客户端同时也具备一个内置的、 使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除(默认90秒)
<br><br>2) 默认情况下，如果EurekaServer在- 定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)
。但是当网络分区故障发生时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了一因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过 “自我保护模式”来解决这个问题一当EurekaServer节 点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。一旦进入该模式， EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据(也就是不会注销任何微服务)。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。
<br><br>3) 在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数重新恢复到阈值以上时，该Eureka 
Server节点就会自动退出自我保护模式。它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解;好死不如赖活着
<br><br>4) 综上，自我保护模式是一种应对网络异常的安全保护措施。 它的架构哲学是宁可同时保留所有微服务(健康的微服务和不健康的微服务都会保留)，也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。
<br><br>在Spring Cloud中，可以使用eureka.server.enable-self-preservation = false 禁用自我保护模式。
<br><br>3. Zookeeper保证CP
<br>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。 但是zk会出现这样-种情况，当master节点因为网络故障 与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于,选举leader的时间太长，30 ~ 120s,且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。
<br><br>4. Eureka保证AP
<br>Eureka看明白了这一点， 因此在设计时就优先保证可用性。`Eureka各个节点都是平等的`，几个节点挂掉不会影响正常节点的工作剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在， 就能保证注册服务可用(保证可用性),只不过查到的信息可能不是最新的(不保证强-致性)。 除此之外，Eureka还有一 种自我保护机制， 如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况:
<br><br>1) Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
<br><br>2) Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用
<br><br>3) 当网络稳定时，当前实例新的注册信息会被同步到其它节点中
<br><br>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。

### 6、分布式会话
### 7、Hystrix
#### Hystrix 熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对`延迟`和`容错`提供更强大的容错能力。
<br>雪崩效应，所有请求在处理一个服务，不能访问其他服务接口。
<br>1.使用超时机制、服务降级
<br>服务降级服务调用接口，如果发生错误或者超时，不让调用接口，调用本地fallback
<br>服务雪崩产生服务堆积，导致其他服务接口无法。
2. 服务雪崩
 多个微服务之向调用的吋候,假设微服务A调用微服务B和微服务C,微服务B和微服务C又调用其它的微服务,这就是所謂的`扇出` 。如果扇出的链路上某个微服务的调用响应时间过长或者不可用,对微服务A的调用就会占用越来越多的系统资源,进而引起系
 统崩溃,所渭的“雪崩效应”
 对于高流量的座用来说,单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和.比失敗更糟糕的是,这些应用程序还可能导致服务之同的延迟増加,备份队列,线程和其他系统资源紧张,导致整个系统发生更的级联故障,
 这些都表示需要对故障和延时逃行隔离和管理,以便単个依赖关系的失败,不能取消整个应用程序或系统.
<br><br>3.如何解决服务雪崩效应
<br><br>1) 超时机制--服务降级处理
<br><br>2) 服务降级服务接口发生错误，不去调用接口，调用本地方法fallback
<br><br>3) 熔断机制类似保险丝 熔断机制就是为解决服务高并发，一旦达到规定请求，熔断，报错。----服务降级
<br><br>4) 隔离机制---每个服务接口隔离开;
<br><br>5） 限流机制nginx使用网关
<br><br>4. SpringCloud hystrix断路器pc远程调用，解决服务雪崩效
<br>服务与服务之间报错信息。
 <br> hystrix断路器服务降级、熔断机制、隔离资源。
 <br><br>5. “断路器”本身是一种开关装置
<br><br>1) 当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝) ,向调用方返回一个符合预期的、可处理的备选响应(FallBack) ,
而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、
不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。
<br><br>2) 服务熔断:服务端。
<br>一般是某个服务故障或者异常引起,类似现实世界中的“保险丝“，当某个异常条件被触发，直接熔断整个服务，而不是一直等到此服务超时。
<br>熔断机制是应对雪崩效应的一种微服务链路保护机制。
<br>当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回"错误”的响应信息。
<br>当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand.
<br><br>6. 服务降级: 客户端
<br>服务降级处理是在客户端实现完成的，与服务端没有关系。整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。
<br>所谓降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，
此时客户端可以自己准备-一个本地的fallback回调，返回-一个缺省值。
这样做，虽然服务水平下降，但好歹可用，比直接挂掉要强。
<br><br>7.调用监控 
<br><br>除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控(Hystrix Dashboard)  Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，
并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。
Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。
<br><br>实心圆:共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色<黄色<橙色<红色递减。
该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示
就可以在大量的实例中快速的发现故障实例和高压力实例。
### 8、负载均街
#### Ribbon 提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。
![](https://github.com/gaoyuanyuan2/distributed/blob/master/img/24.png) 
<br><br>1. Ribbon是什么
<br><br>1) 简单的说，Ribbon是Netlx发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在-一起。Ribbon客户端组件提供一系列完善的配置项如连接超时， 
重试等。简单的说，就是在配置文件中列出Load Balancer (简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等)去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。
<br><br>2) LB,即负载均衡(Load Balance), 在微服务或分布式集群中经常用的一一种应用。
<br><br>3) 负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA。常见的负载均衡有软件Nginx, LVS, 硬件F5等。
<br><br>4) 相应的在中间件，例如: dubbo和SpringCloud中均给我们提供 了负载均衡，SpringCloud的`负载均衡算法可以自定义`。
<br><br>2. Ribbon在工作时分成两步
<br><br>第一步先选择EurekaServer ,它优先选择在同一个区域内负载较少的server.
<br><br>第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。其中Ribbon提供了多种策略:比如轮询、随机和根据响应时间加权。
<br><br>3.均衡算法
<br><br>1) RoundRobinRule  轮询
<br><br>2) RandomRule  随机
<br><br>3) AvailabilityFilteringRule  会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务,
 还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问
<br><br>4) WeightedResponseTimeRule 根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高。刚启动时如果统计信息不足，则使用RoundRobinRule策略， 等统计信息足够， 会切换到WeightedResponseTimeRule
<br><br>5) RetryRule  先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务
<br><br>6) BestAvailableRule  会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择-个并发量最小的服务
<br><br>7) ZoneAvoidanceRule  默认规则，复合判断server所在区域的性能和server的可用性选择服务器
#### Feign 是一种声明式、模板化的HTTP客户端。
<br>1. Feign能干什么
<br>Feign旨在使编写Java Http客户端变得更容易。
前面在使用Ribbon+ RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用， 所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装， 由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口. 上面标注Mapper注解，现在是一个微服务接口上面标注一 个Feign注解即可)， 即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时， 自动封装服务调用客户端的开发量。
<br><br>2. Feign集成了Ribbon
<br>利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用

### 9、全局锁
